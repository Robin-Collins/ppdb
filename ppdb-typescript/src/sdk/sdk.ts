/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SDKHooks } from "../hooks";
import { SDK_METADATA, SDKOptions, serverURLFromOptions } from "../lib/config";
import * as enc$ from "../lib/encodings";
import { HTTPClient } from "../lib/http";
import * as schemas$ from "../lib/schemas";
import { ClientSDK, RequestOptions } from "../lib/sdks";
import * as components from "../models/components";
import * as errors from "../models/errors";
import * as operations from "../models/operations";

export class Ppdb extends ClientSDK {
    private readonly options$: SDKOptions & { hooks?: SDKHooks };

    constructor(options: SDKOptions = {}) {
        const opt = options as unknown;
        let hooks: SDKHooks;
        if (
            typeof opt === "object" &&
            opt != null &&
            "hooks" in opt &&
            opt.hooks instanceof SDKHooks
        ) {
            hooks = opt.hooks;
        } else {
            hooks = new SDKHooks();
        }

        super({
            client: options.httpClient || new HTTPClient(),
            baseURL: serverURLFromOptions(options),
            hooks,
        });

        this.options$ = { ...options, hooks };
        void this.options$;
    }

    /**
     * List all animals
     */
    async getAnimals(
        page?: number | undefined,
        limit?: number | undefined,
        sort?: string | undefined,
        options?: RequestOptions
    ): Promise<operations.GetAnimalsResponse> {
        const input$: operations.GetAnimalsRequest = {
            page: page,
            limit: limit,
            sort: sort,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.GetAnimalsRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/animals")();

        const query$ = [
            enc$.encodeForm("limit", payload$.limit, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("page", payload$.page, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("sort", payload$.sort, { explode: true, charEncoding: "percent" }),
        ]
            .filter(Boolean)
            .join("&");

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "get_/animals",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKeyAuth,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["401", "4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: {
                Response: response,
                Request: request$,
            },
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.GetAnimalsResponse$.inboundSchema.parse({
                        ...responseFields$,
                        Animals: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.UnauthorizedError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else {
            throw new errors.SDKError("Unexpected API response status or content-type", {
                response,
                request: request$,
            });
        }
    }

    /**
     * Create a new animal
     */
    async postAnimals(
        request: components.Animal,
        options?: RequestOptions
    ): Promise<operations.PostAnimalsResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => components.Animal$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/animals")();

        const query$ = "";

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "post_/animals",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKeyAuth,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["400", "401", "4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: {
                Response: response,
                Request: request$,
            },
        };

        if (this.matchStatusCode(response, 201)) {
            // fallthrough
        } else if (this.matchResponse(response, 400, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.BadRequestError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.UnauthorizedError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else {
            throw new errors.SDKError("Unexpected API response status or content-type", {
                response,
                request: request$,
            });
        }

        return schemas$.parse(
            undefined,
            () => operations.PostAnimalsResponse$.inboundSchema.parse(responseFields$),
            "Response validation failed"
        );
    }

    /**
     * Get an animal by ID
     */
    async getAnimalsAnimalID(
        animalID: number,
        options?: RequestOptions
    ): Promise<operations.GetAnimalsAnimalIDResponse> {
        const input$: operations.GetAnimalsAnimalIDRequest = {
            animalID: animalID,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.GetAnimalsAnimalIDRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            animalID: enc$.encodeSimple("animalID", payload$.animalID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/animals/{animalID}")(pathParams$);

        const query$ = "";

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "get_/animals/{animalID}",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKeyAuth,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["401", "404", "4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: {
                Response: response,
                Request: request$,
            },
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.GetAnimalsAnimalIDResponse$.inboundSchema.parse({
                        ...responseFields$,
                        Animal: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.UnauthorizedError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else if (this.matchResponse(response, 404, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.NotFoundError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else {
            throw new errors.SDKError("Unexpected API response status or content-type", {
                response,
                request: request$,
            });
        }
    }

    /**
     * Update an animal
     */
    async putAnimalsAnimalID(
        animalID: number,
        animal: components.Animal,
        options?: RequestOptions
    ): Promise<operations.PutAnimalsAnimalIDResponse> {
        const input$: operations.PutAnimalsAnimalIDRequest = {
            animalID: animalID,
            animal: animal,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.PutAnimalsAnimalIDRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$.Animal, { explode: true });

        const pathParams$ = {
            animalID: enc$.encodeSimple("animalID", payload$.animalID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/animals/{animalID}")(pathParams$);

        const query$ = "";

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "put_/animals/{animalID}",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKeyAuth,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["400", "401", "404", "4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: {
                Response: response,
                Request: request$,
            },
        };

        if (this.matchStatusCode(response, 200)) {
            // fallthrough
        } else if (this.matchResponse(response, 400, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.BadRequestError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.UnauthorizedError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else if (this.matchResponse(response, 404, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.NotFoundError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else {
            throw new errors.SDKError("Unexpected API response status or content-type", {
                response,
                request: request$,
            });
        }

        return schemas$.parse(
            undefined,
            () => operations.PutAnimalsAnimalIDResponse$.inboundSchema.parse(responseFields$),
            "Response validation failed"
        );
    }

    /**
     * Delete an animal
     */
    async deleteAnimalsAnimalID(
        animalID: number,
        options?: RequestOptions
    ): Promise<operations.DeleteAnimalsAnimalIDResponse> {
        const input$: operations.DeleteAnimalsAnimalIDRequest = {
            animalID: animalID,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.DeleteAnimalsAnimalIDRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            animalID: enc$.encodeSimple("animalID", payload$.animalID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/animals/{animalID}")(pathParams$);

        const query$ = "";

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "delete_/animals/{animalID}",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKeyAuth,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["401", "404", "4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: {
                Response: response,
                Request: request$,
            },
        };

        if (this.matchStatusCode(response, 204)) {
            // fallthrough
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.UnauthorizedError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else if (this.matchResponse(response, 404, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.NotFoundError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else {
            throw new errors.SDKError("Unexpected API response status or content-type", {
                response,
                request: request$,
            });
        }

        return schemas$.parse(
            undefined,
            () => operations.DeleteAnimalsAnimalIDResponse$.inboundSchema.parse(responseFields$),
            "Response validation failed"
        );
    }

    /**
     * List all breeds
     */
    async getBreeds(
        page?: number | undefined,
        limit?: number | undefined,
        sort?: string | undefined,
        options?: RequestOptions
    ): Promise<operations.GetBreedsResponse> {
        const input$: operations.GetBreedsRequest = {
            page: page,
            limit: limit,
            sort: sort,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.GetBreedsRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/breeds")();

        const query$ = [
            enc$.encodeForm("limit", payload$.limit, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("page", payload$.page, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("sort", payload$.sort, { explode: true, charEncoding: "percent" }),
        ]
            .filter(Boolean)
            .join("&");

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "get_/breeds",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKeyAuth,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["401", "4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: {
                Response: response,
                Request: request$,
            },
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.GetBreedsResponse$.inboundSchema.parse({
                        ...responseFields$,
                        Breeds: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.UnauthorizedError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else {
            throw new errors.SDKError("Unexpected API response status or content-type", {
                response,
                request: request$,
            });
        }
    }

    /**
     * Create a new breed
     */
    async postBreeds(
        request: components.Breed,
        options?: RequestOptions
    ): Promise<operations.PostBreedsResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => components.Breed$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/breeds")();

        const query$ = "";

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "post_/breeds",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKeyAuth,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["400", "401", "4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: {
                Response: response,
                Request: request$,
            },
        };

        if (this.matchStatusCode(response, 201)) {
            // fallthrough
        } else if (this.matchResponse(response, 400, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.BadRequestError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.UnauthorizedError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else {
            throw new errors.SDKError("Unexpected API response status or content-type", {
                response,
                request: request$,
            });
        }

        return schemas$.parse(
            undefined,
            () => operations.PostBreedsResponse$.inboundSchema.parse(responseFields$),
            "Response validation failed"
        );
    }

    /**
     * Get a breed by ID
     */
    async getBreedsBreedID(
        breedID: number,
        options?: RequestOptions
    ): Promise<operations.GetBreedsBreedIDResponse> {
        const input$: operations.GetBreedsBreedIDRequest = {
            breedID: breedID,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.GetBreedsBreedIDRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            breedID: enc$.encodeSimple("breedID", payload$.breedID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/breeds/{breedID}")(pathParams$);

        const query$ = "";

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "get_/breeds/{breedID}",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKeyAuth,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["401", "404", "4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: {
                Response: response,
                Request: request$,
            },
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.GetBreedsBreedIDResponse$.inboundSchema.parse({
                        ...responseFields$,
                        Breed: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.UnauthorizedError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else if (this.matchResponse(response, 404, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.NotFoundError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else {
            throw new errors.SDKError("Unexpected API response status or content-type", {
                response,
                request: request$,
            });
        }
    }

    /**
     * Update a breed
     */
    async putBreedsBreedID(
        breedID: number,
        breed: components.Breed,
        options?: RequestOptions
    ): Promise<operations.PutBreedsBreedIDResponse> {
        const input$: operations.PutBreedsBreedIDRequest = {
            breedID: breedID,
            breed: breed,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.PutBreedsBreedIDRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$.Breed, { explode: true });

        const pathParams$ = {
            breedID: enc$.encodeSimple("breedID", payload$.breedID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/breeds/{breedID}")(pathParams$);

        const query$ = "";

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "put_/breeds/{breedID}",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKeyAuth,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["400", "401", "404", "4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: {
                Response: response,
                Request: request$,
            },
        };

        if (this.matchStatusCode(response, 200)) {
            // fallthrough
        } else if (this.matchResponse(response, 400, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.BadRequestError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.UnauthorizedError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else if (this.matchResponse(response, 404, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.NotFoundError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else {
            throw new errors.SDKError("Unexpected API response status or content-type", {
                response,
                request: request$,
            });
        }

        return schemas$.parse(
            undefined,
            () => operations.PutBreedsBreedIDResponse$.inboundSchema.parse(responseFields$),
            "Response validation failed"
        );
    }

    /**
     * Delete a breed
     */
    async deleteBreedsBreedID(
        breedID: number,
        options?: RequestOptions
    ): Promise<operations.DeleteBreedsBreedIDResponse> {
        const input$: operations.DeleteBreedsBreedIDRequest = {
            breedID: breedID,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.DeleteBreedsBreedIDRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            breedID: enc$.encodeSimple("breedID", payload$.breedID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/breeds/{breedID}")(pathParams$);

        const query$ = "";

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "delete_/breeds/{breedID}",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKeyAuth,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["401", "404", "4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: {
                Response: response,
                Request: request$,
            },
        };

        if (this.matchStatusCode(response, 204)) {
            // fallthrough
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.UnauthorizedError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else if (this.matchResponse(response, 404, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.NotFoundError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else {
            throw new errors.SDKError("Unexpected API response status or content-type", {
                response,
                request: request$,
            });
        }

        return schemas$.parse(
            undefined,
            () => operations.DeleteBreedsBreedIDResponse$.inboundSchema.parse(responseFields$),
            "Response validation failed"
        );
    }

    /**
     * List all customers
     */
    async getCustomers(
        page?: number | undefined,
        limit?: number | undefined,
        sort?: string | undefined,
        options?: RequestOptions
    ): Promise<operations.GetCustomersResponse> {
        const input$: operations.GetCustomersRequest = {
            page: page,
            limit: limit,
            sort: sort,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.GetCustomersRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/customers")();

        const query$ = [
            enc$.encodeForm("limit", payload$.limit, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("page", payload$.page, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("sort", payload$.sort, { explode: true, charEncoding: "percent" }),
        ]
            .filter(Boolean)
            .join("&");

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "get_/customers",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKeyAuth,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["401", "4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: {
                Response: response,
                Request: request$,
            },
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.GetCustomersResponse$.inboundSchema.parse({
                        ...responseFields$,
                        Customers: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.UnauthorizedError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else {
            throw new errors.SDKError("Unexpected API response status or content-type", {
                response,
                request: request$,
            });
        }
    }

    /**
     * Create a new customer
     */
    async postCustomers(
        request: components.Customer,
        options?: RequestOptions
    ): Promise<operations.PostCustomersResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => components.Customer$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/customers")();

        const query$ = "";

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "post_/customers",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKeyAuth,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["400", "401", "4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: {
                Response: response,
                Request: request$,
            },
        };

        if (this.matchStatusCode(response, 201)) {
            // fallthrough
        } else if (this.matchResponse(response, 400, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.BadRequestError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.UnauthorizedError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else {
            throw new errors.SDKError("Unexpected API response status or content-type", {
                response,
                request: request$,
            });
        }

        return schemas$.parse(
            undefined,
            () => operations.PostCustomersResponse$.inboundSchema.parse(responseFields$),
            "Response validation failed"
        );
    }

    /**
     * Get a customer by ID
     */
    async getCustomersCustomerID(
        customerID: number,
        options?: RequestOptions
    ): Promise<operations.GetCustomersCustomerIDResponse> {
        const input$: operations.GetCustomersCustomerIDRequest = {
            customerID: customerID,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.GetCustomersCustomerIDRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            customerID: enc$.encodeSimple("customerID", payload$.customerID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/customers/{customerID}")(pathParams$);

        const query$ = "";

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "get_/customers/{customerID}",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKeyAuth,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["401", "404", "4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: {
                Response: response,
                Request: request$,
            },
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.GetCustomersCustomerIDResponse$.inboundSchema.parse({
                        ...responseFields$,
                        Customer: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.UnauthorizedError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else if (this.matchResponse(response, 404, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.NotFoundError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else {
            throw new errors.SDKError("Unexpected API response status or content-type", {
                response,
                request: request$,
            });
        }
    }

    /**
     * Update a customer
     */
    async putCustomersCustomerID(
        customerID: number,
        customer: components.Customer,
        options?: RequestOptions
    ): Promise<operations.PutCustomersCustomerIDResponse> {
        const input$: operations.PutCustomersCustomerIDRequest = {
            customerID: customerID,
            customer: customer,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.PutCustomersCustomerIDRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$.Customer, { explode: true });

        const pathParams$ = {
            customerID: enc$.encodeSimple("customerID", payload$.customerID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/customers/{customerID}")(pathParams$);

        const query$ = "";

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "put_/customers/{customerID}",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKeyAuth,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["400", "401", "404", "4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: {
                Response: response,
                Request: request$,
            },
        };

        if (this.matchStatusCode(response, 200)) {
            // fallthrough
        } else if (this.matchResponse(response, 400, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.BadRequestError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.UnauthorizedError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else if (this.matchResponse(response, 404, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.NotFoundError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else {
            throw new errors.SDKError("Unexpected API response status or content-type", {
                response,
                request: request$,
            });
        }

        return schemas$.parse(
            undefined,
            () => operations.PutCustomersCustomerIDResponse$.inboundSchema.parse(responseFields$),
            "Response validation failed"
        );
    }

    /**
     * Delete a customer
     */
    async deleteCustomersCustomerID(
        customerID: number,
        options?: RequestOptions
    ): Promise<operations.DeleteCustomersCustomerIDResponse> {
        const input$: operations.DeleteCustomersCustomerIDRequest = {
            customerID: customerID,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.DeleteCustomersCustomerIDRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            customerID: enc$.encodeSimple("customerID", payload$.customerID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/customers/{customerID}")(pathParams$);

        const query$ = "";

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "delete_/customers/{customerID}",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKeyAuth,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["401", "404", "4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: {
                Response: response,
                Request: request$,
            },
        };

        if (this.matchStatusCode(response, 204)) {
            // fallthrough
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.UnauthorizedError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else if (this.matchResponse(response, 404, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.NotFoundError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else {
            throw new errors.SDKError("Unexpected API response status or content-type", {
                response,
                request: request$,
            });
        }

        return schemas$.parse(
            undefined,
            () =>
                operations.DeleteCustomersCustomerIDResponse$.inboundSchema.parse(responseFields$),
            "Response validation failed"
        );
    }

    /**
     * List all animals owned by a customer
     */
    async getCustomersCustomerIDAnimals(
        customerID: number,
        options?: RequestOptions
    ): Promise<operations.GetCustomersCustomerIDAnimalsResponse> {
        const input$: operations.GetCustomersCustomerIDAnimalsRequest = {
            customerID: customerID,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.GetCustomersCustomerIDAnimalsRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            customerID: enc$.encodeSimple("customerID", payload$.customerID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/customers/{customerID}/animals")(pathParams$);

        const query$ = "";

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "get_/customers/{customerID}/animals",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKeyAuth,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["401", "404", "4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: {
                Response: response,
                Request: request$,
            },
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.GetCustomersCustomerIDAnimalsResponse$.inboundSchema.parse({
                        ...responseFields$,
                        Animals: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.UnauthorizedError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else if (this.matchResponse(response, 404, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.NotFoundError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else {
            throw new errors.SDKError("Unexpected API response status or content-type", {
                response,
                request: request$,
            });
        }
    }

    /**
     * List all notes for an animal
     */
    async getAnimalsAnimalIDNotes(
        animalID: number,
        options?: RequestOptions
    ): Promise<operations.GetAnimalsAnimalIDNotesResponse> {
        const input$: operations.GetAnimalsAnimalIDNotesRequest = {
            animalID: animalID,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.GetAnimalsAnimalIDNotesRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            animalID: enc$.encodeSimple("animalID", payload$.animalID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/animals/{animalID}/notes")(pathParams$);

        const query$ = "";

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "get_/animals/{animalID}/notes",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKeyAuth,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["401", "404", "4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: {
                Response: response,
                Request: request$,
            },
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.GetAnimalsAnimalIDNotesResponse$.inboundSchema.parse({
                        ...responseFields$,
                        Notes: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.UnauthorizedError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else if (this.matchResponse(response, 404, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.NotFoundError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else {
            throw new errors.SDKError("Unexpected API response status or content-type", {
                response,
                request: request$,
            });
        }
    }

    /**
     * List all notes
     */
    async getNotes(
        page?: number | undefined,
        limit?: number | undefined,
        sort?: string | undefined,
        options?: RequestOptions
    ): Promise<operations.GetNotesResponse> {
        const input$: operations.GetNotesRequest = {
            page: page,
            limit: limit,
            sort: sort,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.GetNotesRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/notes")();

        const query$ = [
            enc$.encodeForm("limit", payload$.limit, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("page", payload$.page, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("sort", payload$.sort, { explode: true, charEncoding: "percent" }),
        ]
            .filter(Boolean)
            .join("&");

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "get_/notes",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKeyAuth,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["401", "4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: {
                Response: response,
                Request: request$,
            },
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.GetNotesResponse$.inboundSchema.parse({
                        ...responseFields$,
                        Notes: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.UnauthorizedError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else {
            throw new errors.SDKError("Unexpected API response status or content-type", {
                response,
                request: request$,
            });
        }
    }

    /**
     * Create a new note
     */
    async postNotes(
        request: components.Note,
        options?: RequestOptions
    ): Promise<operations.PostNotesResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => components.Note$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/notes")();

        const query$ = "";

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "post_/notes",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKeyAuth,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["400", "401", "4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: {
                Response: response,
                Request: request$,
            },
        };

        if (this.matchStatusCode(response, 201)) {
            // fallthrough
        } else if (this.matchResponse(response, 400, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.BadRequestError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.UnauthorizedError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else {
            throw new errors.SDKError("Unexpected API response status or content-type", {
                response,
                request: request$,
            });
        }

        return schemas$.parse(
            undefined,
            () => operations.PostNotesResponse$.inboundSchema.parse(responseFields$),
            "Response validation failed"
        );
    }

    /**
     * Get a note by ID
     */
    async getNotesNoteID(
        noteID: number,
        options?: RequestOptions
    ): Promise<operations.GetNotesNoteIDResponse> {
        const input$: operations.GetNotesNoteIDRequest = {
            noteID: noteID,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.GetNotesNoteIDRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            noteID: enc$.encodeSimple("noteID", payload$.noteID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/notes/{noteID}")(pathParams$);

        const query$ = "";

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "get_/notes/{noteID}",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKeyAuth,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["401", "404", "4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: {
                Response: response,
                Request: request$,
            },
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.GetNotesNoteIDResponse$.inboundSchema.parse({
                        ...responseFields$,
                        Note: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.UnauthorizedError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else if (this.matchResponse(response, 404, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.NotFoundError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else {
            throw new errors.SDKError("Unexpected API response status or content-type", {
                response,
                request: request$,
            });
        }
    }

    /**
     * Update a note
     */
    async putNotesNoteID(
        noteID: number,
        note: components.Note,
        options?: RequestOptions
    ): Promise<operations.PutNotesNoteIDResponse> {
        const input$: operations.PutNotesNoteIDRequest = {
            noteID: noteID,
            note: note,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.PutNotesNoteIDRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$.Note, { explode: true });

        const pathParams$ = {
            noteID: enc$.encodeSimple("noteID", payload$.noteID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/notes/{noteID}")(pathParams$);

        const query$ = "";

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "put_/notes/{noteID}",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKeyAuth,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["400", "401", "404", "4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: {
                Response: response,
                Request: request$,
            },
        };

        if (this.matchStatusCode(response, 200)) {
            // fallthrough
        } else if (this.matchResponse(response, 400, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.BadRequestError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.UnauthorizedError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else if (this.matchResponse(response, 404, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.NotFoundError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else {
            throw new errors.SDKError("Unexpected API response status or content-type", {
                response,
                request: request$,
            });
        }

        return schemas$.parse(
            undefined,
            () => operations.PutNotesNoteIDResponse$.inboundSchema.parse(responseFields$),
            "Response validation failed"
        );
    }

    /**
     * Delete a note
     */
    async deleteNotesNoteID(
        noteID: number,
        options?: RequestOptions
    ): Promise<operations.DeleteNotesNoteIDResponse> {
        const input$: operations.DeleteNotesNoteIDRequest = {
            noteID: noteID,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.DeleteNotesNoteIDRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            noteID: enc$.encodeSimple("noteID", payload$.noteID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/notes/{noteID}")(pathParams$);

        const query$ = "";

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "delete_/notes/{noteID}",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKeyAuth,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["401", "404", "4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: {
                Response: response,
                Request: request$,
            },
        };

        if (this.matchStatusCode(response, 204)) {
            // fallthrough
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.UnauthorizedError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else if (this.matchResponse(response, 404, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.NotFoundError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else {
            throw new errors.SDKError("Unexpected API response status or content-type", {
                response,
                request: request$,
            });
        }

        return schemas$.parse(
            undefined,
            () => operations.DeleteNotesNoteIDResponse$.inboundSchema.parse(responseFields$),
            "Response validation failed"
        );
    }

    /**
     * List all users
     */
    async getUsers(options?: RequestOptions): Promise<operations.GetUsersResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const path$ = this.templateURLComponent("/users")();

        const query$ = "";

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "get_/users",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKeyAuth,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["401", "4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: {
                Response: response,
                Request: request$,
            },
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.GetUsersResponse$.inboundSchema.parse({
                        ...responseFields$,
                        Users: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.UnauthorizedError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else {
            throw new errors.SDKError("Unexpected API response status or content-type", {
                response,
                request: request$,
            });
        }
    }

    /**
     * Create a new user
     */
    async postUsers(
        request: components.User,
        options?: RequestOptions
    ): Promise<operations.PostUsersResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => components.User$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/users")();

        const query$ = "";

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "post_/users",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKeyAuth,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["400", "401", "4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: {
                Response: response,
                Request: request$,
            },
        };

        if (this.matchStatusCode(response, 201)) {
            // fallthrough
        } else if (this.matchResponse(response, 400, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.BadRequestError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.UnauthorizedError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else {
            throw new errors.SDKError("Unexpected API response status or content-type", {
                response,
                request: request$,
            });
        }

        return schemas$.parse(
            undefined,
            () => operations.PostUsersResponse$.inboundSchema.parse(responseFields$),
            "Response validation failed"
        );
    }

    /**
     * Get a user by ID
     */
    async getUsersUserID(
        userID: number,
        options?: RequestOptions
    ): Promise<operations.GetUsersUserIDResponse> {
        const input$: operations.GetUsersUserIDRequest = {
            userID: userID,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.GetUsersUserIDRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            userID: enc$.encodeSimple("userID", payload$.userID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/users/{userID}")(pathParams$);

        const query$ = "";

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "get_/users/{userID}",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKeyAuth,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["401", "404", "4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: {
                Response: response,
                Request: request$,
            },
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.GetUsersUserIDResponse$.inboundSchema.parse({
                        ...responseFields$,
                        User: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.UnauthorizedError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else if (this.matchResponse(response, 404, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.NotFoundError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else {
            throw new errors.SDKError("Unexpected API response status or content-type", {
                response,
                request: request$,
            });
        }
    }

    /**
     * Update a user
     */
    async putUsersUserID(
        userID: number,
        user: components.User,
        options?: RequestOptions
    ): Promise<operations.PutUsersUserIDResponse> {
        const input$: operations.PutUsersUserIDRequest = {
            userID: userID,
            user: user,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.PutUsersUserIDRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$.User, { explode: true });

        const pathParams$ = {
            userID: enc$.encodeSimple("userID", payload$.userID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/users/{userID}")(pathParams$);

        const query$ = "";

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "put_/users/{userID}",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKeyAuth,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["400", "401", "404", "4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: {
                Response: response,
                Request: request$,
            },
        };

        if (this.matchStatusCode(response, 200)) {
            // fallthrough
        } else if (this.matchResponse(response, 400, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.BadRequestError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.UnauthorizedError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else if (this.matchResponse(response, 404, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.NotFoundError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else {
            throw new errors.SDKError("Unexpected API response status or content-type", {
                response,
                request: request$,
            });
        }

        return schemas$.parse(
            undefined,
            () => operations.PutUsersUserIDResponse$.inboundSchema.parse(responseFields$),
            "Response validation failed"
        );
    }

    /**
     * Delete a user
     */
    async deleteUsersUserID(
        userID: number,
        options?: RequestOptions
    ): Promise<operations.DeleteUsersUserIDResponse> {
        const input$: operations.DeleteUsersUserIDRequest = {
            userID: userID,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.DeleteUsersUserIDRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            userID: enc$.encodeSimple("userID", payload$.userID, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/users/{userID}")(pathParams$);

        const query$ = "";

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "delete_/users/{userID}",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKeyAuth,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["401", "404", "4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: {
                Response: response,
                Request: request$,
            },
        };

        if (this.matchStatusCode(response, 204)) {
            // fallthrough
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.UnauthorizedError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else if (this.matchResponse(response, 404, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.NotFoundError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else {
            throw new errors.SDKError("Unexpected API response status or content-type", {
                response,
                request: request$,
            });
        }

        return schemas$.parse(
            undefined,
            () => operations.DeleteUsersUserIDResponse$.inboundSchema.parse(responseFields$),
            "Response validation failed"
        );
    }

    /**
     * Search across customers and animals
     */
    async getSearch(
        query: string,
        options?: RequestOptions
    ): Promise<operations.GetSearchResponse> {
        const input$: operations.GetSearchRequest = {
            query: query,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.GetSearchRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/search")();

        const query$ = [
            enc$.encodeForm("query", payload$.query, { explode: true, charEncoding: "percent" }),
        ]
            .filter(Boolean)
            .join("&");

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "get_/search",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKeyAuth,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["401", "4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: {
                Response: response,
                Request: request$,
            },
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.GetSearchResponse$.inboundSchema.parse({
                        ...responseFields$,
                        responseBodies: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return errors.UnauthorizedError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else {
            throw new errors.SDKError("Unexpected API response status or content-type", {
                response,
                request: request$,
            });
        }
    }
}
